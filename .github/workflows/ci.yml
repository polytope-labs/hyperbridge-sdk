name: CI

on:
    push:
        branches: [main]
    pull_request:
        branches: [main]

jobs:
    test:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v3
              with:
                  fetch-depth: 0

            - name: Setup Node.js
              uses: actions/setup-node@v3
              with:
                  node-version: "22"

            - name: Setup PNPM
              uses: pnpm/action-setup@v2
              with:
                  version: 7

            - name: Install dependencies
              run: pnpm install

            - name: Build SDK
              run: cd packages/sdk && pnpm build

            - name: Setup environment for testing
              run: |
                  # Create environment file content
                  ENV_CONTENT="# TESTNET RPCS
                  HYPERBRIDGE_GARGANTUA=${{ secrets.HYPERBRIDGE_GARGANTUA }}
                  BSC_CHAPEL=${{ secrets.BSC_CHAPEL }}
                  GNOSIS_CHIADO=${{ secrets.GNOSIS_CHIADO }}

                  # DATABASE
                  DB_USER=\"postgres\"
                  DB_PASS=\"postgres\"
                  DB_DATABASE=\"postgres\"
                  DB_HOST=\"localhost\"
                  DB_PORT=5432
                  DB_PATH=\"/tmp/postgres-data\"

                  # ENVIRONMENT
                  CURRENT_ENV=\"local\"

                  # SUBQL SETTINGS
                  SUB_COMMAND=-f
                  SUBQL_WORKERS=1
                  SUBQL_BATCH_SIZE=5

                  # KEYS
                  PRIVATE_KEY=${{ secrets.PRIVATE_KEY }}
                  PING_MODULE_ADDRESS=${{ secrets.PING_MODULE_ADDRESS }}"

                  # Create environment file at root level
                  echo "$ENV_CONTENT" > .env

                  # Create environment file in indexer folder
                  echo "$ENV_CONTENT" > packages/indexer/.env

                  # Create database directory
                  mkdir -p /tmp/postgres-data

            - name: Build and prepare indexer
              run: |
                  cd packages/indexer
                  
                  # Generate YAML configs and build
                  pnpm run codegen:yamls
                  pnpm run codegen:subql
                  pnpm run build
                  
                  # Create a proper directory structure for SubQL
                  mkdir -p /tmp/subql-app
                  cp configs/*.yaml /tmp/subql-app/
                  cp configs/schema.graphql /tmp/subql-app/ || echo "No schema.graphql found"
                  
                  # Copy all build artifacts
                  mkdir -p /tmp/subql-app/dist
                  cp -r dist/* /tmp/subql-app/dist/
                  
                  # Copy chaintypes files if they exist
                  mkdir -p /tmp/subql-app/dist/substrate-chaintypes || true
                  cp -r dist/substrate-chaintypes/* /tmp/subql-app/dist/substrate-chaintypes/ || echo "No chaintypes found"
                  
                  # Modify YAML files to use absolute paths instead of relative ones
                  sed -i 's|file: \./|file: /app/|g' /tmp/subql-app/*.yaml
                  grep -r "file:" /tmp/subql-app/*.yaml
                  
                  # Ensure all files are readable
                  chmod -R 755 /tmp/subql-app
                  
                  # Update docker-compose.testnet.yml to use absolute paths
                  sed -i 's|../configs:/app|/tmp/subql-app:/app|g' docker/docker-compose.testnet.yml
                  sed -i 's|../dist:/app/dist|/tmp/subql-app/dist:/app/dist|g' docker/docker-compose.testnet.yml
                  
                  # Verify the directory structure
                  echo "Directory structure:"
                  find /tmp/subql-app -type f | sort
                  
                  # Verify docker-compose changes
                  echo "Modified docker-compose:"
                  grep -A 5 volumes docker/docker-compose.testnet.yml

            - name: Start Postgres
              run: |
                  cd packages/indexer
                  
                  # Start only the Postgres container
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d postgres
                  
                  # Wait for PostgreSQL to be ready
                  echo "Waiting for PostgreSQL..."
                  timeout 60s bash -c 'until docker exec $(docker ps -q -f name=postgres) pg_isready -U postgres; do sleep 2; echo "Waiting..."; done'
                  
                  # Initialize database schema
                  docker exec $(docker ps -q -f name=postgres) psql -U postgres -d postgres -c "CREATE SCHEMA IF NOT EXISTS app;"
                  docker exec $(docker ps -q -f name=postgres) psql -U postgres -d postgres -c "CREATE EXTENSION IF NOT EXISTS btree_gist;"
                  
                  # Check network information
                  echo "Docker network information:"
                  docker network ls
                  NETWORK_NAME=$(docker inspect $(docker ps -q -f name=postgres) --format '{{.HostConfig.NetworkMode}}')
                  echo "Postgres container is on network: $NETWORK_NAME"

            - name: Test network connectivity
              run: |
                  # Create a test container to verify connectivity to Postgres
                  echo "Testing network connectivity to Postgres..."
                  docker run --rm --network=$(docker inspect $(docker ps -q -f name=postgres) --format '{{.HostConfig.NetworkMode}}') \
                    alpine sh -c "apk add --no-cache iputils postgresql-client && ping -c 2 postgres && pg_isready -h postgres -U postgres"
                    
                  echo "Postgres is reachable from containers on the same network."

            - name: Test direct SubQL node run
              run: |
                  cd packages/indexer
                  
                  # Get the network name that Postgres is on
                  NETWORK_NAME=$(docker inspect $(docker ps -q -f name=postgres) --format '{{.HostConfig.NetworkMode}}')
                  
                  # Try running a SubQL node directly with explicit arguments
                  echo "Attempting direct run of SubQL node for hyperbridge-gargantua..."
                  docker run --rm \
                    --network=$NETWORK_NAME \
                    -v /tmp/subql-app:/app \
                    -e DB_USER=postgres \
                    -e DB_PASS=postgres \
                    -e DB_DATABASE=postgres \
                    -e DB_HOST=postgres \
                    -e DB_PORT=5432 \
                    subquerynetwork/subql-node-substrate:v5.9.1 \
                    -f=/app/hyperbridge-gargantua.yaml \
                    --db-schema=app \
                    --log-level=debug \
                    --unsafe \
                    --force-clean
                    
                  # If the above works, then we know our configuration is good
                  # If it fails, we'll see detailed logs

            - name: Start SubQL nodes with docker-compose
              run: |
                  cd packages/indexer
                  
                  # Start one node first as a test
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d subquery-node-hyperbridge-gargantua
                  
                  # Wait and check logs
                  sleep 10
                  echo "SubQL node logs:"
                  docker logs $(docker ps -q -f name=subquery-node-hyperbridge-gargantua) || true
                  
                  # Start the remaining services if the first node started successfully
                  if docker ps | grep -q subquery-node-hyperbridge-gargantua; then
                      echo "First node started successfully, starting remaining services..."
                      docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d
                  else
                      echo "First node failed to start, something is wrong with the configuration"
                      exit 1
                  fi

            - name: Wait for services to be ready
              run: |
                  # Wait for GraphQL API
                  echo "Waiting for GraphQL API..."
                  max_attempts=15
                  attempt=0
                  until curl -s http://localhost:3000/graphql -o /dev/null || [ $attempt -ge $max_attempts ]; do
                      attempt=$((attempt+1))
                      echo "Waiting for GraphQL... attempt $attempt of $max_attempts"
                      
                      if [ $attempt -eq 10 ]; then
                          # Show more verbose logs at attempt 10
                          echo "Checking container status..."
                          docker ps -a
                          
                          echo "GraphQL logs:"
                          docker logs $(docker ps -q -f name=graphql-engine) || true
                      fi
                      
                      sleep 10
                  done
                  
                  if [ $attempt -ge $max_attempts ]; then
                      echo "GraphQL service failed to start properly"
                      exit 1
                  fi
                  
                  echo "All services are running!"

            - name: Run SDK tests
              run: |
                  cd packages/sdk
                  pnpm test
              env:
                  INDEXER_GRAPHQL_URL: http://localhost:3000/graphql
                  BSC_CHAPEL: ${{ secrets.BSC_CHAPEL }}
                  GNOSIS_CHIADO: ${{ secrets.GNOSIS_CHIADO }}
                  HYPERBRIDGE_GARGANTUA: ${{ secrets.HYPERBRIDGE_GARGANTUA }}
                  PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
                  PING_MODULE_ADDRESS: ${{ secrets.PING_MODULE_ADDRESS }}

            - name: Show logs on failure
              if: failure()
              run: |
                  echo "==== POSTGRES LOGS ===="
                  docker logs $(docker ps -q -f name=postgres) || true
                  
                  echo "==== GRAPHQL ENGINE LOGS ===="
                  docker logs $(docker ps -q -f name=graphql-engine) || true
                  
                  for container in $(docker ps -q -f name=subquery-node); do
                      echo "==== LOGS FOR $(docker inspect --format '{{.Name}}' $container) ===="
                      docker logs $container || true
                  done
                  
                  echo "==== FILE STRUCTURE ===="
                  find /tmp/subql-app -type f | sort
                  
                  echo "==== YAML CONTENTS ===="
                  cat /tmp/subql-app/hyperbridge-gargantua.yaml

            - name: Cleanup
              if: always()
              run: |
                  cd packages/indexer
                  docker compose -f docker/docker-compose.testnet.yml down -v
