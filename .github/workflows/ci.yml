name: CI

on:
    push:
        branches: [main]
    pull_request:
        branches: [main]

jobs:
    test:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v3
              with:
                  fetch-depth: 0

            - name: Setup Node.js
              uses: actions/setup-node@v3
              with:
                  node-version: "22"

            - name: Setup PNPM
              uses: pnpm/action-setup@v2
              with:
                  version: 7

            - name: Install dependencies
              run: pnpm install

            - name: Build SDK
              run: cd packages/sdk && pnpm build

            - name: Setup environment for testing
              run: |
                  # Create environment file content
                  ENV_CONTENT="# TESTNET RPCS
                  HYPERBRIDGE_GARGANTUA=${{ secrets.HYPERBRIDGE_GARGANTUA }}
                  BSC_CHAPEL=${{ secrets.BSC_CHAPEL }}
                  GNOSIS_CHIADO=${{ secrets.GNOSIS_CHIADO }}

                  # DATABASE
                  DB_USER=\"postgres\"
                  DB_PASS=\"postgres\"
                  DB_DATABASE=\"postgres\"
                  DB_HOST=\"localhost\"
                  DB_PORT=5432
                  DB_PATH=\"/tmp/postgres-data\"

                  # ENVIRONMENT
                  CURRENT_ENV=\"local\"

                  # SUBQL SETTINGS
                  SUB_COMMAND=-f
                  SUBQL_WORKERS=1
                  SUBQL_BATCH_SIZE=5

                  # KEYS
                  PRIVATE_KEY=${{ secrets.PRIVATE_KEY }}
                  PING_MODULE_ADDRESS=${{ secrets.PING_MODULE_ADDRESS }}"

                  # Create environment file at root level
                  echo "$ENV_CONTENT" > .env

                  # Create environment file in indexer folder
                  echo "$ENV_CONTENT" > packages/indexer/.env

                  # Create database directory
                  mkdir -p /tmp/postgres-data

            - name: Build and prepare indexer
              run: |
                  cd packages/indexer
                  
                  # Generate YAML configs and build
                  pnpm run codegen:yamls
                  pnpm run codegen:subql
                  pnpm run build
                  
                  # Create a proper directory structure for SubQL
                  mkdir -p /tmp/subql-app
                  cp configs/*.yaml /tmp/subql-app/
                  cp configs/schema.graphql /tmp/subql-app/ || echo "No schema.graphql found"
                  
                  # Copy all build artifacts
                  mkdir -p /tmp/subql-app/dist
                  cp -r dist/* /tmp/subql-app/dist/
                  
                  # Copy chaintypes files if they exist
                  mkdir -p /tmp/subql-app/dist/substrate-chaintypes || true
                  cp -r dist/substrate-chaintypes/* /tmp/subql-app/dist/substrate-chaintypes/ || echo "No chaintypes found"
                  
                  # Modify YAML files to use absolute paths instead of relative ones
                  sed -i 's|file: \./|file: /app/|g' /tmp/subql-app/*.yaml
                  
                  # Update the start block heights to skip potential sync issues
                  # This is only for CI testing purposes
                  echo "Adjusting start blocks to avoid sync issues..."
                  for file in /tmp/subql-app/*.yaml; do
                    # Get a current block height from a few blocks back
                    current_height=$(grep -o 'startBlock: [0-9]*' $file | awk '{print $2}')
                    if [ ! -z "$current_height" ]; then
                      # Use a height that's safely reachable
                      new_height=$((current_height + 100))
                      sed -i "s/startBlock: $current_height/startBlock: $new_height/g" $file
                      echo "Updated $file: startBlock $current_height -> $new_height"
                    fi
                  done
                  
                  # Ensure all files are readable
                  chmod -R 755 /tmp/subql-app
                  
                  # Update docker-compose file to use our prepared folder
                  sed -i 's|../configs:/app|/tmp/subql-app:/app|g' docker/docker-compose.testnet.yml
                  sed -i 's|../dist:/app/dist|/tmp/subql-app/dist:/app/dist|g' docker/docker-compose.testnet.yml

            - name: Start Postgres
              run: |
                  cd packages/indexer
                  
                  # Start only the Postgres container
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d postgres
                  
                  # Wait for PostgreSQL to be ready
                  echo "Waiting for PostgreSQL..."
                  timeout 60s bash -c 'until docker exec $(docker ps -q -f name=postgres) pg_isready -U postgres; do sleep 2; echo "Waiting..."; done'
                  
                  # Initialize database schema
                  docker exec $(docker ps -q -f name=postgres) psql -U postgres -d postgres -c "CREATE SCHEMA IF NOT EXISTS app;"
                  docker exec $(docker ps -q -f name=postgres) psql -U postgres -d postgres -c "CREATE EXTENSION IF NOT EXISTS btree_gist;"
                  
                  # Get the network name that Postgres is on for later use
                  NETWORK_NAME=$(docker inspect $(docker ps -q -f name=postgres) --format '{{.HostConfig.NetworkMode}}')
                  echo "Postgres container is on network: $NETWORK_NAME"

            - name: Start services sequentially
              run: |
                  cd packages/indexer
                  NETWORK_NAME=$(docker inspect $(docker ps -q -f name=postgres) --format '{{.HostConfig.NetworkMode}}')
                  
                  # Start the SubQL nodes one by one
                  echo "Starting hyperbridge-gargantua node..."
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d subquery-node-hyperbridge-gargantua
                  sleep 5
                  
                  echo "Starting bsc-chapel node..."
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d subquery-node-bsc-chapel
                  sleep 5
                  
                  echo "Starting gnosis-chiado node..."
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d subquery-node-gnosis-chiado
                  sleep 5
                  
                  # Initialize metadata in the database (this helps GraphQL connect)
                  echo "Initializing metadata tables..."
                  docker exec $(docker ps -q -f name=postgres) psql -U postgres -d postgres -c "
                  SET search_path TO app;
                  CREATE TABLE IF NOT EXISTS _metadata (
                      key TEXT PRIMARY KEY,
                      value JSONB NOT NULL,
                      \"createdAt\" TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                      \"updatedAt\" TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                  );
                  INSERT INTO _metadata (key, value) VALUES 
                  ('schemaVersion', '\"0.0.1\"'), 
                  ('lastProcessedHeight', '0'),
                  ('genesisHash', '\"0x0\"')
                  ON CONFLICT DO NOTHING;
                  "
                  
                  # Finally start GraphQL engine
                  echo "Starting GraphQL engine..."
                  docker compose -f docker/docker-compose.testnet.yml --env-file .env up -d graphql-engine
                  
                  # Check all services
                  docker ps

            - name: Wait for services to be ready
              run: |
                  # Give services time to initialize
                  echo "Waiting for services to initialize..."
                  sleep 20
                  
                  # Check if GraphQL is accessible
                  echo "Checking GraphQL API..."
                  max_attempts=10
                  attempt=0
                  until curl -s http://localhost:3000/graphql -o /dev/null || [ $attempt -ge $max_attempts ]; do
                      attempt=$((attempt+1))
                      echo "Waiting for GraphQL... attempt $attempt of $max_attempts"
                      sleep 10
                  done
                  
                  if [ $attempt -ge $max_attempts ]; then
                      echo "GraphQL service failed to start properly"
                      docker logs $(docker ps -q -f name=graphql-engine)
                      exit 1
                  fi
                  
                  echo "GraphQL API is accessible!"

            - name: Run SDK tests
              run: |
                  cd packages/sdk
                  pnpm test
              env:
                  INDEXER_GRAPHQL_URL: http://localhost:3000/graphql
                  BSC_CHAPEL: ${{ secrets.BSC_CHAPEL }}
                  GNOSIS_CHIADO: ${{ secrets.GNOSIS_CHIADO }}
                  HYPERBRIDGE_GARGANTUA: ${{ secrets.HYPERBRIDGE_GARGANTUA }}
                  PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
                  PING_MODULE_ADDRESS: ${{ secrets.PING_MODULE_ADDRESS }}

            - name: Show logs on failure
              if: failure()
              run: |
                  echo "==== POSTGRES LOGS ===="
                  docker logs $(docker ps -q -f name=postgres) || true
                  
                  echo "==== GRAPHQL ENGINE LOGS ===="
                  docker logs $(docker ps -q -f name=graphql-engine) || true
                  
                  for container in $(docker ps -q -f name=subquery-node); do
                      echo "==== LOGS FOR $(docker inspect --format '{{.Name}}' $container) ===="
                      docker logs $container || true
                  done

            - name: Cleanup
              if: always()
              run: |
                  cd packages/indexer
                  docker compose -f docker/docker-compose.testnet.yml down -v
