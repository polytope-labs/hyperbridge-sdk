{"version":3,"file":"generate.js","sourceRoot":"","sources":["../../../src/commands/codegen/generate.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport fs, {lstatSync} from 'fs';\nimport path from 'path';\nimport type {EventFragment, FunctionFragment} from '@ethersproject/abi';\nimport {Command, Flags} from '@oclif/core';\nimport {DEFAULT_MANIFEST, DEFAULT_TS_MANIFEST, extensionIsTs, NETWORK_FAMILY} from '@subql/common';\nimport type {SubqlRuntimeDatasource as EthereumDs} from '@subql/types-ethereum';\nimport {\n  constructMethod,\n  filterExistingMethods,\n  filterObjectsByStateMutability,\n  generateHandlers,\n  generateManifestTs,\n  generateManifestYaml,\n  getManifestData,\n  ManifestExtractor,\n  prepareAbiDirectory,\n  prepareInputFragments,\n  tsExtractor,\n  yamlExtractor,\n} from '../../controller/generate-controller';\nimport {loadDependency} from '../../modulars';\nimport {extractFromTs} from '../../utils';\n\nexport interface SelectedMethod {\n  name: string;\n  method: string;\n}\nexport interface UserInput {\n  startBlock: number;\n  functions: SelectedMethod[];\n  events: SelectedMethod[];\n  abiPath: string;\n  address?: string;\n}\n\nexport default class Generate extends Command {\n  static description = 'Generate Project.yaml and mapping functions based on provided ABI';\n\n  static flags = {\n    file: Flags.string({char: 'f', description: 'specify manifest file path'}),\n    events: Flags.string({description: 'abi events, --events=\"approval, transfer\"'}),\n    functions: Flags.string({description: 'abi functions,  --functions=\"approval, transfer\"'}),\n    abiPath: Flags.string({description: 'path to abi from root', required: true}),\n    startBlock: Flags.integer({description: 'startBlock', required: true}),\n    address: Flags.string({description: 'contract address'}),\n  };\n\n  private prepareUserInput<T>(\n    selectedEvents: Record<string, EventFragment>,\n    selectedFunctions: Record<string, FunctionFragment>,\n    existingDs: T,\n    address: string | undefined,\n    startBlock: number,\n    abiFileName: string,\n    extractor: ManifestExtractor<T>\n  ): UserInput {\n    const [cleanEvents, cleanFunctions] = filterExistingMethods(\n      selectedEvents,\n      selectedFunctions,\n      existingDs,\n      address,\n      extractor\n    );\n\n    const constructedEvents = constructMethod<EventFragment>(cleanEvents);\n    const constructedFunctions = constructMethod<FunctionFragment>(cleanFunctions);\n\n    return {\n      startBlock: startBlock,\n      functions: constructedFunctions,\n      events: constructedEvents,\n      abiPath: `./abis/${abiFileName}`,\n      address: address,\n    };\n  }\n  async run(): Promise<void> {\n    const {flags} = await this.parse(Generate);\n    const {abiPath, address, events, file, functions, startBlock} = flags;\n    let manifest: string, root: string;\n    let isTs: boolean;\n\n    const projectPath = path.resolve(file ?? process.cwd());\n\n    if (lstatSync(projectPath).isDirectory()) {\n      if (fs.existsSync(path.join(projectPath, DEFAULT_TS_MANIFEST))) {\n        manifest = path.join(projectPath, DEFAULT_TS_MANIFEST);\n        isTs = true;\n      } else {\n        manifest = path.join(projectPath, DEFAULT_MANIFEST);\n        isTs = false;\n      }\n      root = projectPath;\n    } else if (lstatSync(projectPath).isFile()) {\n      const {dir, ext} = path.parse(projectPath);\n      root = dir;\n      isTs = extensionIsTs(ext);\n      manifest = projectPath;\n    } else {\n      this.error('Invalid manifest path');\n    }\n\n    const ethModule = loadDependency(NETWORK_FAMILY.ethereum);\n    const abiName = ethModule.parseContractPath(abiPath).name;\n\n    if (fs.existsSync(path.join(root, 'src/mappings/', `${abiName}Handlers.ts`))) {\n      throw new Error(`file: ${abiName}Handlers.ts already exists`);\n    }\n\n    await prepareAbiDirectory(abiPath, root);\n    const abiFileName = path.basename(abiPath);\n\n    // fragments from abi\n    const abiInterface = ethModule.getAbiInterface(root, abiFileName);\n    const eventsFragments = abiInterface.events;\n    const functionFragments = filterObjectsByStateMutability(abiInterface.functions);\n\n    const selectedEvents = await prepareInputFragments('event', events, eventsFragments, abiName);\n    const selectedFunctions = await prepareInputFragments('function', functions, functionFragments, abiName);\n\n    let userInput: UserInput;\n\n    try {\n      if (isTs) {\n        const existingManifest = await fs.promises.readFile(manifest, 'utf8');\n        const extractedDatasources = extractFromTs(existingManifest, {\n          dataSources: undefined,\n        });\n        const existingDs = extractedDatasources.dataSources as string;\n\n        userInput = this.prepareUserInput(\n          selectedEvents,\n          selectedFunctions,\n          existingDs,\n          address,\n          startBlock,\n          abiFileName,\n          tsExtractor\n        );\n\n        await generateManifestTs(manifest, userInput, existingManifest);\n      } else {\n        // yaml\n        const existingManifest = await getManifestData(manifest);\n        const existingDs = ((existingManifest.get('dataSources') as any)?.toJSON() as EthereumDs[]) ?? [];\n\n        userInput = this.prepareUserInput(\n          selectedEvents,\n          selectedFunctions,\n          existingDs,\n          address,\n          startBlock,\n          abiFileName,\n          yamlExtractor\n        );\n\n        await generateManifestYaml(manifest, userInput, existingManifest);\n      }\n\n      await generateHandlers([userInput.events, userInput.functions], root, abiName);\n\n      this.log('-----------Generated-----------');\n      userInput.functions.forEach((fn) => {\n        this.log(`Function: ${fn.name} successfully generated`);\n      });\n      userInput.events.forEach((event) => {\n        this.log(`Event: ${event.name} successfully generated`);\n      });\n      this.log('-------------------------------');\n    } catch (e: any) {\n      this.error(e);\n    }\n  }\n}\n"]}