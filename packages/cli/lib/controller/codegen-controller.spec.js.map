{"version":3,"file":"codegen-controller.spec.js","sourceRoot":"","sources":["../../src/controller/codegen-controller.spec.ts"],"names":[],"mappings":";AAAA,8DAA8D;AAC9D,mCAAmC;;;AAEnC,oDAAoB;AACpB,wDAAwB;AACxB,mCAA8B;AAC9B,6DAAgF;AAEhF,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE;IACnB,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IACpC,OAAO;QACL,GAAG,EAAE;QACL,QAAQ,EAAE;YACR,GAAG,EAAE,CAAC,QAAQ;YACd,KAAK,EAAE,IAAI,CAAC,EAAE,EAAE;SACjB;KACF,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE;IACvB,OAAO,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAY,CAAC;AACxD,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AAEvB,QAAQ,CAAC,sCAAsC,EAAE,GAAG,EAAE;IACpD,MAAM,WAAW,GAAG,cAAI,CAAC,IAAI,CAAC,SAAS,EAAE,kBAAkB,CAAC,CAAC;IAC7D,EAAE,CAAC,gEAAgE,EAAE,KAAK,IAAI,EAAE;QAC7E,eAA+B,CAAC,kBAAkB,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;QACvE,YAAE,CAAC,QAAQ,CAAC,KAAmB,CAAC,kBAAkB,CAAC,KAAK,IAAI,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC;QAC7F,MAAM,MAAM,CAAC,IAAA,4BAAO,EAAC,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC;IAC1E,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,oCAAoC,EAAE,GAAG,EAAE;QAC5C,MAAM,SAAS,GAAG,qBAAqB,CAAC;QACxC,MAAM,WAAW,GAAG,IAAA,uCAAkB,EAAC,SAAS,CAAC,CAAC;QAClD,MAAM,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAEvC,MAAM,QAAQ,GAAG,sBAAsB,CAAC;QACxC,MAAM,CAAC,GAAG,EAAE,CAAC,IAAA,uCAAkB,EAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAChD,uEAAuE,CACxE,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6DAA6D,EAAE,GAAG,EAAE;QACrE,MAAM,CAAC,GAAG,EAAE,CACV,IAAA,kCAAa,EACX,WAAW,EACX,kBAAkB,EAClB;YACE,2CAA2C;YAC3C;gBACE,IAAI,EAAE,cAAc;gBACpB,IAAI,EAAE,mBAAmB;gBACzB,QAAQ,EAAE,KAAK;gBACf,OAAO,EAAE,KAAK;gBACd,MAAM,EAAE,KAAK;aACd;SACF,EACD,EAAE,CACH,CACF,CAAC,OAAO,CACP,0GAA0G,CAC3G,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport fs from 'fs';\nimport path from 'path';\nimport {rimraf} from 'rimraf';\nimport {codegen, processFields, validateEntityName} from './codegen-controller';\n\njest.mock('fs', () => {\n  const fs = jest.requireActual('fs');\n  return {\n    ...fs,\n    promises: {\n      ...fs.promises,\n      mkdir: jest.fn(),\n    },\n  };\n});\n\njest.mock('rimraf', () => {\n  return jest.createMockFromModule('rimraf') as unknown;\n});\n\njest.setTimeout(30000);\n\ndescribe('Codegen can generate schema (mocked)', () => {\n  const projectPath = path.join(__dirname, '../../test/test1');\n  it('throw error when make directory failed at beginning of codegen', async () => {\n    (rimraf as unknown as jest.Mock).mockImplementation((path, cb) => cb());\n    (fs.promises.mkdir as jest.Mock).mockImplementation(async () => Promise.reject(new Error()));\n    await expect(codegen(projectPath)).rejects.toThrow(/Failed to prepare/);\n  });\n\n  it('test codegen reserved key validate', () => {\n    const good_name = 'exampleFilterEntity';\n    const good_result = validateEntityName(good_name);\n    expect(good_result).toEqual(good_name);\n\n    const bad_name = 'exampleEntityFilters';\n    expect(() => validateEntityName(bad_name)).toThrow(\n      'EntityName: exampleEntityFilters cannot end with reservedKey: filters'\n    );\n  });\n\n  it('throw error when processing unsupported type in json fields', () => {\n    expect(() =>\n      processFields(\n        'jsonField',\n        'TypeNotSupported',\n        [\n          // Ignoring to test unsupported scalar type\n          {\n            name: 'notSupported',\n            type: 'UnsupportedScalar',\n            nullable: false,\n            isArray: false,\n            isEnum: false,\n          },\n        ],\n        []\n      )\n    ).toThrow(\n      'Schema: undefined type \"UnsupportedScalar\" on field \"notSupported\" in \"type TypeNotSupported @jsonField\"'\n    );\n  });\n});\n"]}