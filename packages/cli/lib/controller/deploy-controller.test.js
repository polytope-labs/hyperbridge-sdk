"use strict";
// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const deploy_controller_1 = require("./deploy-controller");
const project_controller_1 = require("./project-controller");
jest.setTimeout(120000);
const projectSpec = {
    org: process.env.SUBQL_ORG_TEST,
    projectName: 'mockedStarter',
    ipfs: 'Qmdr4yg98Fv8Yif3anjKVHhjuAKR665j6ekhWsfYUdkaCu',
    subtitle: 'This project is generated by SubQuery SDK integration tests',
    description: '',
    logoURL: '',
    type: 'stage',
};
async function deployTestProject(validator, ipfs, org, project_name, testAuth, url) {
    const indexerV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.node.name, validator.manifestRunner.node.version, testAuth, url);
    const queryV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.query.name, validator.manifestRunner.query.version, testAuth, url);
    const endpoint = 'wss://polkadot.api.onfinality.io/public-ws';
    const project = {
        cid: ipfs,
        endpoint,
        indexerImageVersion: indexerV[0],
        indexerAdvancedSettings: {
            indexer: {},
        },
    };
    return (0, deploy_controller_1.createDeployment)(org, project_name, testAuth, ipfs, queryV[0], projectSpec.type, {}, [project], url);
}
// Replace/Update your access token when test locally
const testAuth = process.env.SUBQL_ACCESS_TOKEN;
// Can be re-enabled when test env is ready
describe('CLI deploy, delete, promote', () => {
    beforeAll(async () => {
        const { description, logoURL, org, projectName, subtitle } = projectSpec;
        if (!projectSpec.org) {
            throw new Error(`Please set SUBQL_ORG_TEST env var.`);
        }
        const project = await (0, project_controller_1.getProject)(constants_1.ROOT_API_URL_PROD, testAuth, `${org}/${projectName}`);
        if (project) {
            console.warn('Project already exists, these tests could be being run in parallel');
            return;
        }
        await (0, project_controller_1.createProject)(constants_1.ROOT_API_URL_PROD, testAuth, {
            apiVersion: 'v3',
            key: `${org}/${projectName}`,
            logoUrl: logoURL,
            name: projectName,
            description,
            subtitle,
            tag: [],
            type: 1,
        });
    });
    afterAll(async () => {
        try {
            await (0, project_controller_1.deleteProject)(testAuth, projectSpec.org, projectSpec.projectName, constants_1.ROOT_API_URL_PROD);
        }
        catch (e) {
            console.warn('Failed to delete project', e);
        }
    });
    it('Deploy to Hosted Service and Delete', async () => {
        const { ipfs, org, projectName } = projectSpec;
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(ipfs, testAuth, constants_1.ROOT_API_URL_PROD);
        const deploy_output = await deployTestProject(validator, ipfs, org, projectName, testAuth, constants_1.ROOT_API_URL_PROD);
        const del_output = await (0, deploy_controller_1.deleteDeployment)(org, projectName, testAuth, deploy_output.id, constants_1.ROOT_API_URL_PROD);
        expect(typeof deploy_output.id).toBe('number');
        expect(+del_output).toBe(deploy_output.id);
    });
    // Only test locally
    // eslint-disable-next-line jest/no-disabled-tests
    it.skip('Promote Deployment', async () => {
        const { ipfs, org, projectName } = projectSpec;
        let status;
        let attempt = 0;
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(ipfs, testAuth, constants_1.ROOT_API_URL_PROD);
        const deployOutput = await deployTestProject(validator, ipfs, org, projectName, testAuth, constants_1.ROOT_API_URL_PROD);
        while (status !== 'running') {
            if (attempt >= 5)
                break;
            attempt = attempt + 1;
            await (0, utils_1.delay)(30);
            status = await (0, deploy_controller_1.deploymentStatus)(org, projectName, testAuth, deployOutput.id, constants_1.ROOT_API_URL_PROD);
            if (status === 'running') {
                const promoteOutput = await (0, deploy_controller_1.promoteDeployment)(org, projectName, testAuth, deployOutput.id, constants_1.ROOT_API_URL_PROD);
                // eslint-disable-next-line jest/no-conditional-expect
                expect(+promoteOutput).toBe(deployOutput.id);
            }
        }
    });
    it('should return true for valid ipfsCID', async () => {
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(projectSpec.ipfs, testAuth, constants_1.ROOT_API_URL_PROD);
        expect(validator.valid).toBe(true);
    });
    it('to throw error for invalid ipfsCID', async () => {
        await expect((0, deploy_controller_1.ipfsCID_validate)('fake', testAuth, constants_1.ROOT_API_URL_PROD)).rejects.toThrow('Failed to validate IPFS CID: fake is not a valid subquery deployment id!');
    });
    it('reDeploy to Hosted Service', async () => {
        const { ipfs, org, projectName, type } = projectSpec;
        const newIPFS = 'Qmdr4yg98Fv8Yif3anjKVHhjuAKR665j6ekhWsfYUdkaCu';
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(projectSpec.ipfs, testAuth, constants_1.ROOT_API_URL_PROD);
        const deployOutput = await deployTestProject(validator, ipfs, org, projectName, testAuth, constants_1.ROOT_API_URL_PROD);
        const initProjectInfo = await (0, deploy_controller_1.projectsInfo)(testAuth, org, projectName, constants_1.ROOT_API_URL_PROD, type);
        const endpoint = 'wss://polkadot.api.onfinality.io/public-ws';
        const indexerV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.node.name, validator.manifestRunner.node.version, testAuth, constants_1.ROOT_API_URL_PROD);
        const queryV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.query.name, validator.manifestRunner.query.version, testAuth, constants_1.ROOT_API_URL_PROD);
        const project = {
            cid: ipfs,
            endpoint,
            indexerImageVersion: indexerV[0],
            indexerAdvancedSettings: {
                indexer: {},
            },
        };
        await (0, deploy_controller_1.updateDeployment)(org, projectName, deployOutput.id, testAuth, newIPFS, queryV[0], {}, [project], constants_1.ROOT_API_URL_PROD);
        const updatedInfo = await (0, deploy_controller_1.projectsInfo)(testAuth, org, projectName, constants_1.ROOT_API_URL_PROD, type);
        expect(updatedInfo.id).toBe(initProjectInfo.id);
        expect(updatedInfo.version).not.toEqual(deployOutput.version);
    });
});
//# sourceMappingURL=deploy-controller.test.js.map