{"version":3,"file":"migrate-schema.controller.spec.js","sourceRoot":"","sources":["../../../../src/controller/migrate/schema/migrate-schema.controller.spec.ts"],"names":[],"mappings":";AAAA,8DAA8D;AAC9D,mCAAmC;;AAEnC,2EAAoE;AAEpE,QAAQ,CAAC,mCAAmC,EAAE,GAAG,EAAE;IACjD,EAAE,CAAC,6BAA6B,EAAE,GAAG,EAAE;QACrC,6HAA6H;QAC7H,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAmGd,CAAC;QAEF,MAAM,cAAc,GAAG,IAAA,mDAAuB,EAAC,MAAM,CAAC,CAAC;QAEvD,OAAO,CAAC,GAAG,CAAC,iBAAiB,EAAE,cAAc,CAAC,CAAC;QAE/C,MAAM,CAAC,cAAc,CAAC,CAAC,eAAe,EAAE,CAAC;IAC3C,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport {migrateSchemaFromString} from './migrate-schema.controller';\n\ndescribe('Subgraph Graphql Schema migration', () => {\n  it('correctly migrates a schema', () => {\n    // This schema is a mix of schemas from https://github.com/graphprotocol/graph-tooling/tree/main/examples as well as the docs\n    const schema = `\n    type _Schema_\n    @fulltext(\n      name: \"exampleSearch\"\n      language: en\n      algorithm: rank\n      include: [{ entity: \"ExampleEntity\", fields: [{ name: \"optionalString\" }, { name: \"requiredString\" }, { name: \"optionalStringList\" }] }]\n    )\n\n    \"\"\"\n    The Example entity has an example of various fields\n    \"\"\"\n    type ExampleEntity @entity {\n      \"\"\"\n      The id is required and a unique identifier of the entity\n      \"\"\"\n      id: ID!\n\n      optionalBoolean: Boolean\n      requiredBoolean: Boolean!\n      optionalBooleanList: [Boolean!]\n      requiredBooleanList: [Boolean!]!\n\n      optionalString: String\n      requiredString: String!\n      optionalStringList: [String!]\n      requiredStringList: [String!]!\n\n      optionalBytes: Bytes\n      requiredBytes: Bytes!\n      optionalBytesList: [Bytes!]\n      requiredBytesList: [Bytes!]!\n\n      optionalInt: Int\n      requiredInt: Int!\n      optionalIntList: [Int!]\n      requiredIntList: [Int!]!\n\n      optionalInt8: Int8\n      requiredInt8: Int8!\n      optionalInt8List: [Int8!]\n      requiredInt8List: [Int8!]!\n\n      optionalBigInt: BigInt\n      requiredBigInt: BigInt!\n      optionalBigIntList: [BigInt!]\n      requiredBigIntList: [BigInt!]!\n\n      optionalBigDecimal: BigDecimal\n      requiredBigDecimal: BigDecimal!\n      optionalBigDecimalList: [BigDecimal!]\n      requiredBigDecimalList: [BigDecimal!]!\n\n      optionalTimestamp: Timestamp\n      requiredTimestamp: Timestamp!\n      optionalTimestampList: [Timestamp!]\n      requiredTimestampList: [Timestamp!]!\n\n      optionalReference: OtherEntity\n      requiredReference: OtherEntity!\n      optionalReferenceList: [OtherEntity!]\n      requiredReferenceList: [OtherEntity!]!\n\n      derivedEntity: [FooEntity!]! @derivedFrom(field: \"example\")\n      derivedEntity2: [FooEntity!]!\n    }\n\n    type OtherEntity @entity(immutable: true, timeseries: true) {\n      id: ID!\n    }\n\n    type FooEntity @entity {\n      id: Bytes!\n\n      example: ExampleEntity!\n    }\n\n    type Stats @aggregation(intervals: [\"hour\", \"day\"], source: \"Block\") {\n      # The id; it is the id of one of the data points that were aggregated into\n      # this bucket, but which one is undefined and should not be relied on\n      id: Int8!\n      # The timestamp of the bucket is always the timestamp of the beginning of\n      # the interval\n      timestamp: Timestamp!\n\n      # The aggregates\n\n      # A count of the number of data points that went into this bucket\n      count: Int! @aggregate(fn: \"count\")\n      # The max(number) of the data points for this bucket\n      max: BigDecimal! @aggregate(fn: \"max\", arg: \"number\")\n      min: BigDecimal! @aggregate(fn: \"min\", arg: \"number\")\n      # sum_{i=n}^m i = (m - n + 1) * (n + m) / 2\n      sum: BigInt! @aggregate(fn: \"sum\", arg: \"number\")\n      first: Int! @aggregate(fn: \"first\", arg: \"number\")\n      last: Int! @aggregate(fn: \"last\", arg: \"number\")\n      maxGas: BigInt! @aggregate(fn: \"max\", arg: \"gasUsed\")\n      maxDifficulty: BigInt! @aggregate(fn: \"max\", arg: \"difficulty\")\n    }\n    `;\n\n    const migratedSchema = migrateSchemaFromString(schema);\n\n    console.log('Migrated schema', migratedSchema);\n\n    expect(migratedSchema).toMatchSnapshot();\n  });\n});\n"]}