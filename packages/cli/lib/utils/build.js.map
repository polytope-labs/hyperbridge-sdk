{"version":3,"file":"build.js","sourceRoot":"","sources":["../../src/utils/build.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors\n// SPDX-License-Identifier: GPL-3.0\n\nimport assert from 'assert';\nimport {existsSync, lstatSync, readFileSync, writeFileSync} from 'fs';\nimport path from 'path';\nimport {\n  DEFAULT_MULTICHAIN_MANIFEST,\n  DEFAULT_MULTICHAIN_TS_MANIFEST,\n  DEFAULT_TS_MANIFEST,\n  tsProjectYamlPath,\n} from '@subql/common';\nimport {MultichainProjectManifest} from '@subql/types-core';\nimport * as yaml from 'js-yaml';\nimport * as tsNode from 'ts-node';\nimport {isMultichain} from './utils';\n\nconst requireScriptWrapper = (scriptPath: string, outputPath: string): string =>\n  `import {toJsonObject} from '@subql/common';` +\n  `const {writeFileSync} = require('fs');` +\n  `const yaml = require('js-yaml');` +\n  `const project = toJsonObject((require('${scriptPath}')).default);` +\n  `const yamlOutput = yaml.dump(project);` +\n  `writeFileSync('${outputPath}', '# // Auto-generated , DO NOT EDIT\\\\n' + yamlOutput);`;\n\n// Replaces \\ in path on windows that don't work with require\nfunction formatPath(p: string): string {\n  return p.replace(/\\\\/g, '/');\n}\n\nexport async function buildManifestFromLocation(location: string, log: (...args: any[]) => void): Promise<string> {\n  let directory: string;\n  let projectManifestEntry: string;\n  // lstatSync will throw if location not exist\n  if (lstatSync(location).isDirectory()) {\n    directory = location;\n    projectManifestEntry = path.join(directory, DEFAULT_TS_MANIFEST);\n  } else if (lstatSync(location).isFile()) {\n    directory = path.dirname(location);\n    projectManifestEntry = location;\n  } else {\n    throw new Error('Argument `location` is not a valid directory or file');\n  }\n\n  // We compile from TypeScript every time, even if the current YAML file exists, to ensure that the YAML file remains up-to-date with the latest changes\n  try {\n    //we could have a multichain yaml with ts projects inside it\n    const projectYamlPath = projectManifestEntry.endsWith('.ts')\n      ? await generateManifestFromTs(projectManifestEntry, log)\n      : projectManifestEntry;\n\n    if (isMultichain(projectYamlPath)) {\n      const tsManifests = getTsManifestsFromMultichain(projectYamlPath);\n      await Promise.all(tsManifests.map((manifest) => generateManifestFromTs(manifest, log)));\n      replaceTsReferencesInMultichain(projectYamlPath);\n    }\n  } catch (e: any) {\n    console.log(e);\n    throw new Error(`Failed to generate manifest from typescript ${projectManifestEntry}, ${e.message}`);\n  }\n  return directory;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function generateManifestFromTs(\n  projectManifestEntry: string,\n  log: (...args: any[]) => void\n): Promise<string> {\n  assert(existsSync(projectManifestEntry), `${projectManifestEntry} does not exist`);\n  const projectYamlPath = tsProjectYamlPath(projectManifestEntry);\n  try {\n    // Allows requiring TS, this allows requirng the projectManifestEntry ts file\n    const tsNodeService = tsNode.register({transpileOnly: true});\n\n    // Compile the above script\n    const script = tsNodeService.compile(\n      requireScriptWrapper(formatPath(projectManifestEntry), formatPath(projectYamlPath)),\n      'inline.ts'\n    );\n\n    // Run compiled code\n    eval(script);\n\n    log(`Project manifest generated to ${projectYamlPath}`);\n\n    return projectYamlPath;\n  } catch (error) {\n    throw new Error(`Failed to build ${projectManifestEntry}: ${error}`);\n  }\n}\n\n//Returns either the single chain ts manifest or the multichain ts/yaml manifest\nexport function getTsManifest(location: string): string | null {\n  let manifest: string;\n\n  if (lstatSync(location).isDirectory()) {\n    //default ts manifest\n    manifest = path.join(location, DEFAULT_TS_MANIFEST);\n    if (existsSync(manifest)) {\n      return manifest;\n    } else {\n      //default multichain ts manifest\n      manifest = path.join(location, DEFAULT_MULTICHAIN_TS_MANIFEST);\n      if (existsSync(manifest)) {\n        return manifest;\n      } else {\n        //default yaml multichain manifest\n        manifest = path.join(location, DEFAULT_MULTICHAIN_MANIFEST);\n        if (existsSync(manifest)) {\n          return manifest;\n        }\n      }\n    }\n  } else if (lstatSync(location).isFile()) {\n    if (location.endsWith('.ts') || isMultichain(location)) {\n      return location;\n    }\n  }\n\n  return null;\n}\n\nfunction getTsManifestsFromMultichain(location: string): string[] {\n  const multichainContent = yaml.load(readFileSync(location, 'utf8')) as MultichainProjectManifest;\n\n  if (!multichainContent || !multichainContent.projects) {\n    return [];\n  }\n\n  return multichainContent.projects\n    .filter((project) => project.endsWith('.ts'))\n    .map((project) => path.resolve(path.dirname(location), project));\n}\n\nfunction replaceTsReferencesInMultichain(location: string): void {\n  const multichainContent = yaml.load(readFileSync(location, 'utf8')) as MultichainProjectManifest;\n  multichainContent.projects = multichainContent.projects.map((project) => tsProjectYamlPath(project));\n  const yamlOutput = yaml.dump(multichainContent);\n  writeFileSync(location, yamlOutput);\n}\n"]}