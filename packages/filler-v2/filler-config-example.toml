# Hyperbridge Intent Filler Simplified Configuration
# This is a minimal configuration file that leverages the SDK's built-in chain configurations
# Copy this file to filler-config.toml and update with your actual values

# Filler configuration
[filler]
privateKey = ""  # Replace with your actual EVM private key (not required if all chains are watchOnly)
maxConcurrentOrders = 5

# Directory for persistent data storage (bid transaction hashes, etc.)
# Bid storage enables later cleanup and fund recovery from Hyperbridge
# Default: ".filler-data" in current working directory
# dataDir = "/path/to/data"

# ===== Solver Selection Mode Configuration =====
# Required when solver selection is active on any chain

# Substrate private key for signing Hyperbridge extrinsics
# Can be a hex seed (without 0x prefix) or mnemonic phrase
# Note: Submitting bids to Hyperbridge requires BRIDGE tokens for transaction fees
substratePrivateKey = ""

# Hyperbridge WebSocket URL
hyperbridgeWsUrl = ""

# ERC-4337 EntryPoint contract address
entryPointAddress = ""

# Address of the deployed SolverAccount.sol contract
# The filler's EOA will delegate to this contract via EIP-7702
# This enables the filler to participate in solver selection mode
solverAccountContractAddress = ""

# ERC-4337 bundler URL for UserOperation gas estimation
bundlerUrl = ""

# Gas fee bump configuration (optional)
# These values control how much to bump gas fees for UserOperation submission
# Both are percentages added ON TOP of the base gasPrice
# If not provided, defaults will be used (8% for priority fee, 10% for max fee)
# [filler.gasFeeBump]
# maxPriorityFeePerGasBumpPercent = 8   # Percentage added to gasPrice for priority fee (default: 8)
# maxFeePerGasBumpPercent = 10          # Percentage added to gasPrice for max fee (default: 10)

# Watch-only mode configuration
# Option 1: Global watch-only (all chains)
# watchOnly = true

# Option 2: Per-chain watch-only configuration
# [filler.watchOnly]
# "1" = true   # Ethereum Mainnet - watch only
# "56" = false  # BSC Mainnet - normal execution
# "137" = true  # Polygon Mainnet - watch only

# Logging configuration
[filler.logging]
level = "debug"  # Options: trace, debug, info, warn, error

# Pending queue configuration
[filler.pendingQueue]
maxRechecks = 10
recheckDelayMs = 30000  # 30 seconds

# Rebalancing configuration
# Trigger percentage: rebalancing triggers when balance falls to (1 - triggerPercentage) * baseBalance
# Example: triggerPercentage = 0.5 means trigger when balance <= 50% of base
[rebalancing]
triggerPercentage = 0.5

# Base balances per chain and per asset (in USD value, treated as $1 per token)
# Format: [rebalancing.baseBalances."USDC"] or [rebalancing.baseBalances."USDT"]
# Then specify per chainId as string keys
[rebalancing.baseBalances."USDC"]
"1" = "10000"      # Ethereum Mainnet: $10k USDC base
"56" = "10000"     # BSC Mainnet: $10k USDC base
"42161" = "10000"  # Arbitrum: $10k USDC base
"8453" = "10000"   # Base: $10k USDC base
"137" = "10000"    # Polygon: $10k USDC base
"130" = "10000"    # Unichain: $10k USDC base

[rebalancing.baseBalances."USDT"]
"1" = "10000"      # Ethereum Mainnet: $10k USDT base
"56" = "10000"     # BSC Mainnet: $10k USDT base
"42161" = "10000"  # Arbitrum: $10k USDT base
"8453" = "10000"   # Base: $10k USDT base
"137" = "10000"    # Polygon: $10k USDT base
"130" = "10000"    # Unichain: $10k USDT base

# Strategy configuration
# You can configure multiple strategies
# All strategies use the filler.privateKey from above
[[strategies]]
type = "basic"
# Filler BPS (basis points) curve based on order value
# Uses polynomial interpolation to create a smooth curve through all points
# - Small orders: Higher BPS to make filling worthwhile  
# - Large orders: Lower BPS to be more competitive
bpsCurve = [
    { amount = "100", value = 100 },      # $100 orders: 1% margin
    { amount = "1000", value = 50 },      # $1000 orders: 0.5% margin
    { amount = "10000", value = 25 },     # $10000 orders: 0.25% margin
    { amount = "100000", value = 10 },    # $100000 orders: 0.1% margin
]


# Chain configuration - RPC URLs are required
# All other chain data (addresses, assets, etc.) comes from the SDK automatically
[[chains]]
chainId = 1  # Ethereum Mainnet
rpcUrl = ""  # Required: your RPC URL

[[chains]]
chainId = 56  # BSC Mainnet
rpcUrl = ""  # Required: your RPC URL

[[chains]]
chainId = 42161  # Arbitrum Mainnet
rpcUrl = ""  # Required: your RPC URL

[[chains]]
chainId = 8453  # Base Mainnet
rpcUrl = ""  # Required: your RPC URL

[[chains]]
chainId = 137  # Polygon Mainnet
rpcUrl = ""  # Required: your RPC URL

[[chains]]
chainId = 130  # Unichain Mainnet
rpcUrl = ""  # Required: your RPC URL


# Confirmation policies per chain
# Uses polynomial interpolation to create a smooth curve through all points
# The chain ID should match the numeric ID from the chain configuration

[confirmationPolicies."97"]  # BSC Testnet
points = [
    { amount = "1", value = 1 },
    { amount = "1000", value = 5 },
]

[confirmationPolicies."10200"]  # Gnosis Chiado
points = [
    { amount = "1", value = 1 },
    { amount = "1000", value = 5 },
]

[confirmationPolicies."1"]  # Ethereum Mainnet
points = [
    { amount = "5", value = 3 },
    { amount = "500", value = 6 },
    { amount = "5000", value = 12 },
]

[confirmationPolicies."56"]  # BSC Mainnet
points = [
    { amount = "1", value = 3 },
    { amount = "500", value = 6 },
    { amount = "5000", value = 15 },
]

[confirmationPolicies."11155111"]  # Sepolia
points = [
    { amount = "1", value = 1 },
    { amount = "1000", value = 5 },
]

[confirmationPolicies."42161"]  # Arbitrum Mainnet
points = [
    { amount = "2", value = 2 },
    { amount = "1000", value = 5 },
    { amount = "8000", value = 10 },
]

[confirmationPolicies."8453"]  # Base Mainnet
points = [
    { amount = "2", value = 2 },
    { amount = "1000", value = 5 },
    { amount = "8000", value = 10 },
]

[confirmationPolicies."137"]  # Polygon Mainnet
points = [
    { amount = "2", value = 2 },
    { amount = "1000", value = 5 },
    { amount = "8000", value = 10 },
]

[confirmationPolicies."130"]  # Unichain Mainnet
points = [
    { amount = "2", value = 2 },
    { amount = "1000", value = 5 },
    { amount = "8000", value = 10 },
]