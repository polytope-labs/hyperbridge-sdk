import fs from 'fs';
import path from 'path';
import fetch from 'node-fetch';
import { fileURLToPath } from 'url';
import { OPTIMISM, BASE } from '../src/constants';

const SUPERCHAIN_REGISTRY_URL = 'https://raw.githubusercontent.com/ethereum-optimism/superchain-registry/main/chainList.json';

interface OpStackChain {
	name: string;
	chainId: number;
	identifier: string;
	superchainLevel: number;
}

async function generateL2ChainsFile() {
	console.log(`Fetching OP Stack L2 chains from ${SUPERCHAIN_REGISTRY_URL}...`);

	try {
		const __dirname = path.dirname(fileURLToPath(import.meta.url));

		const hardcodedL2s = [OPTIMISM.mainnet, BASE.mainnet];

		const response = await fetch(SUPERCHAIN_REGISTRY_URL);
		if (!response.ok) {
			throw new Error(`Failed to fetch chain list: ${response.statusText}`);
		}
		const chainList: OpStackChain[] = await response.json() as OpStackChain[];

		const outputPath = path.resolve(__dirname, '../src/utils/l2-state-machine.helper.ts');

		const fetchedL2s = chainList
			.filter(chain => chain.identifier.startsWith('mainnet/'))
			.map(chain => `EVM-${chain.chainId}`);

		const combinedL2s = [...hardcodedL2s, ...fetchedL2s];
		const uniqueL2s = [...new Set(combinedL2s)];

		const fileContent = `
// THIS FILE IS AUTO-GENERATED BY 'scripts/generate-l2-chains.ts'. DO NOT EDIT.

export const GET_ETHEREUM_L2_STATE_MACHINES = (): string[] => {
    return ${JSON.stringify(uniqueL2s.sort(), null, 8)};
};
        `;

		fs.writeFileSync(outputPath, fileContent.trim());
		console.log(`Successfully generated ${uniqueL2s.length} unique L2 chains to ${outputPath}`);
	} catch (error) {
		console.error('Error generating L2 chains file:', error);
		process.exit(1);
	}
}

generateL2ChainsFile();